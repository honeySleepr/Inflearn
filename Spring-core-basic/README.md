# 스프링 핵심원리(기본편) - 김영한님 강의

# 강의

### 스프링 부트란?

스프링 프레임워크와 다음 기능들을 함께 제공한다

* Tomcat 웹서버를 내장하고 있다.
* 빌드에 필요한 라이브러리들을 알아서 구성해준다.
* 현재 스프링 프레임워크 버전과 호환되는 최신 버전의 외부 라이브러리를 자동으로 구성해준다
* 각종 설정들이 기본값으로 설정되어있다

### 다형성

* 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.
* 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.
* 코드를 역할과 구현으로 분리함으로써 다형성을 구현할 수 있다.

## SOLID

### SRP

단일 책임 원칙
> 한 클래스는 하나의 책임만 가져야 한다.

* 클라이언트 객체는 실행만 담당하고 구현 객체를 생성하고 연결하는 책임은 AppConfig가 담당

> **조용호**님 강의에서:
> 여러 사람이 한 클래스에 대해 커밋을 하고 있으면 SRT 위반!
> ->  한 클래스에 대해서는 한 사람만 커밋 하도록 클래스들을 나누자(개꿀팁)
> 클래스가 변경될 이유가 하나밖에 없다 = 응집도가 높다 = SRT 원칙을 따른다

### OCP (특히 중요)

개방 폐쇄 원칙
> 기능 확장에는 열려있되, 기존 코드의 변경에는 닫혀 있어야 한다.

* ::기존 코드를 변경하지 않고, 새로운 코드만 추가해서 기능 확장을 할 수 있어야 한다!::
* AppConfig를 통해 **사용 영역**과 **구성 영역**으로 나누고, 클라이언트 코드가 추상화에 의존함으로써
* 다른 구체 클래스로 확장을 하더라도 클라이언트 코드의 변경은 하지 않는 상태를 만듬 ——>**OCP 준수!**

### LSP

리스코프 치환 원칙
> 하위 클래스는 인터페이스의 규약을 다 지켜야한다.

* 인터페이스를 구현한 구현체를 믿고 사용하기 위해 필요한 원칙.
* ex) accelerate 메서드는 앞으로 전진하는 기능으로 정해졌는데 뒤로 가게 구현하면 LSP 위반

### ISP

인터페이스 분리 원칙
> 인터페이스도 단일 책임을 가지도록 분리해야한다.

* SRP의 인터페이스 버전이라고 할 수 있다.

### DIP (특히 중요)

의존관계 역전 원칙
> 구체화에 의존하면 안되고 추상화에 의존해야한다.

* 클라이언트는 인터페이스에만 의존해야한다. 구현 객체에는 의존하면 안된다.
* AppConfig를 쓰기 전까지는 Service 클래스에서
  `Repository repository = new MemoryRepository()`
  형태로 선언되어 추상화(Repsitory)와 구체화(MemoryRepository)에 동시에 의존하는 형태였다. -> DIP 위반!

* AppConfig을 사용함으로써 Service는 추상화인 Repository만 알고 있게 되었다. -> DIP 준수!

---

## 관심사의 분리

AppConfig가 생성자를 통해 의존관계를 주입해줌으로써
**MemberServiceImpl** 은 **구체클래스에서는 일절 관여할 필요 없이**(생성자를 통해 어떤 구현체가 주입될지 알 수 없다) Repository 인터페이스만 알고있는 상태로 실행에만 집중할 수 있다.

AppConfig가 공연 기획자 역할을 한다. 구현체들은 배우들이다. 배우들은 다른 배우들은 신경 쓸 것 없이 자신의 배역(인터페이스)만 알고 실행(대본)에만 집중하면 된다.

애플리케이션의 사용 영역(Client)과 구성(Config) 영역이 나뉘게 되었다.

---

## IoC

제어의 역전

* 기존에는 클라이언트 구현 객체가 스스로 구현 객체를 생성하고, 연결하고, 실행 하였다
* AppConfig가 등장함으로서 프로그램 제어권이 AppConfig에게 넘어갔다.

## DI

의존관계 주입

> 의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고,
> 동적인 객체 인스턴스 의존관계를 변경할 수 있다.

* 정적 클래스 의존 관계 : 컴파일 타임에 확인할 수 있는 의존 관계
* 동적 클래스 의존 관계: 런타임에 확인 할 수 있는 의존 관계
* DI 컨테이너 : 자바 객체들을 Bean 형태로 넣어두는 곳.

여기서 쓰이는 AppConfig 처럼 객체를 생성하고 의존관계를 관리해주는 역할을 하는 것을 **DI 컨테이너**(or IoC컨테이너)라고 한다!
(또는 어셈블러, 오브젝트 팩토리)

### 프레임워크 VS 라이브러리

* 내가 작성한 코드를 제어하고, 대신 실행하면 그게 바로 **프레임워크**!
* 반면에 내가 작성한 코드가 직접 제어의 흐름을 담당하면 그게 **라이브러리**!

---

## @Configuration

> 설정 정보로 사용할 클래스를 지정하는 Annotation

### @Bean

> Bean으로 사용할 메서드를 지정하는 Annotation

* @Bean이 붙은 메서드로부터 **반환되는 객체**들을 스프링 컨테이너에 등록한다
  * 이 객체들이 **스프링 빈**이다.
  * Bean의 이름은 메서드명, value는 메서드의 반환값이다.
    * Bean 이름이 겹치면 안된다

### ApplicationContext

> 스프링 컨테이너로서 등록된 Bean들을 관리한다

* `applicationContext.getBean("메서드명", 반환타입)` 을 통해 등록된 Bean을 꺼낸다

* `ApplicationContext`는 **인터페이스**이고,
* 그 구현체 중 하나가 `AnnotationConfigApplicationContext`

---

## BeanFactory 와 ApplicationContext

> **BeanFactory** 인터페이스에 부가 기능을 더한 것이 **ApplicationContext** 인터페이스

**BeanFactory** : 빈 조회하고 관리하는 걸 담당
**ApplicationContext** : 빈팩토리의 기능을 모두 상속 받아서 제공함. 거기에 +

* 국제화 기능 : 한글파일, 영어 파일 등 나눠줌
* 환경변수 : 개발 환경별 설정들을 처리해줌
* 애플리케이션 이벤트
* 편리한 리소스 조회

등등 애플리케이션 개발 시 필요한 기능들도 제공. 그래서 BeanFactory를 이용할 일은 없고 ApplicationContext만 사용한다고 보면된다 이를 **스프링 컨테이너**라고 한다

### 상속관계의 Bean 조회

> 부모타입으로 Bean 조회 시 자식타입이 전부 같이 조회된다

## xml 설정

* xml 기반의 설정은 요즘은 잘 안쓰이지만 여전히 쓰는데도 있으니 알아두자.
* appConfig.java와 비교해보면 구조가 완전 똑같다

* .java 파일이 아닌 다은 전부 resources로 들어가면 된다

## 스프링 빈 설정 메타 정보 - BeanDefinition

@Bean, <bean> 하나 할 때 마다 메타정보가 하나씩 생성되는 것이다. BeanDefinition을 직접 생성해서 스프링 컨테이너를 등록 할 수도 있지만, 그럴 일은 없다. 그냥 BeanDefinition이
추상화가 되어있기 때문에 다양한 설정 방식이 다 적용된다~ 정도만 이해하자

## 싱글톤 패턴

문제점

* 의존관계상 클라이언트가 구체 클래스에 의존한다(DIP 위반)
* 테스트하기 어렵다
* 등등..
* ->결론적으로 유연성이 떨어진다

스프링은 객체들을 싱글톤으로 관리하면서 싱글톤 패턴의 단점들은 제거하였다.

### 싱글톤 방식의 주의점

무상태로 설계해야한다!

* 특정 클라이언트에 의존적인 필드가 있으면 안된다
* 가급적이면 읽기만 가능해야하고, 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다!!
* 스프링 빈의 필드에 공유 값을 설정하면 위험쓰!!

### CGLIBS

@Bean 이 붙은 메서드마다 이미 스프링 빈이 존재하면 그 빈을 반환하고, 존재하지 않으면 해당 메서드를 호출해서 빈을 새로 생성한다. 이렇게 싱글톤을 유지한다

### @Configuration 을 안붙이고 @Bean만 붙여둔다면?

CGLIBS가 적용되지 않아서 싱글톤이 깨진다 (ex:  memberRepository 가 여러번 호출 된다)

### @ComponentScan

* @Component가 붙은 클래스를 찾아서 자동으로 스프링빈으로 등록해준다
* 스캔의 default 범위는 @ComponentScan 이 붙은 클래스가 위치한 디렉토리 내의 모든 디렉토리이다.
  (ex: `com.hello`, `com.hello.controller`,`com.hello.repository` 같은 구조로 되어있다면, 이 설정파일은 `com.hello`에 두는 것이 좋다)
* @SpringBootApplication (Main 클래스에 붙어있음) 에 @Component 스캔이 포함되어 있기 때문에 사실 따로 붙여줄 필요가 없다..?!

### @Service

* 비즈니스 로직이 주로 담기는 곳. 하지만 스프링에서 특별한 처리를 하는것은 아니다

### 수동 빈과 자동 빈의 이름이 겹칠 경우

* 수동빈이 우선순위를 가진다.
* 하지만 최근 스프링은 `spring.main.allow-bean-definition-overriding=false` 가 default로 되어있어서 겹치는 빈이 있다면 아예 에러를 내버린다.

> 깔끔하지만 헷갈리는 로직 보다는, 중복이 있더라도 명확한 로직을 구현하자.


---

## 의존 관계 주입 방법

## 생성자 주입

* 생성자가 하나일때는 @Autowired 를 생략하여도 된다.
* 빈을 등록하면서 의존성 주입도 바로 같이 일어난다

## 수정자(setter) 주입

* 외부에서 의존성을 건드릴 수 있기 때문에 추천하지 않는 방법
* 선택, 변경 가능성이 있는 의존관계에 사용

## 필드 주입

`@Autowired private final MemberRepository memberRepository`

* 외부에서 조작을 할 수 없어서 테스트가 힘들다. 차라리 setter 주입이 낫다.
* 테스트코드 내에서와 같은 특수한 경우에만 쓰고, 애플리케이션 내에서는 쓰지맛!
